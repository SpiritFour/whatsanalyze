{"version":3,"sources":["webpack:///./components/Attachment.vue?e978","webpack:///./functions/attachments.ts","webpack:///./components/Attachment.vue?7ec8","webpack:///./components/Attachment.vue?9fa2","webpack:///./components/Attachment.vue?d2d0","webpack:///./components/Attachment.vue","webpack:///./components/Attachment.vue?a88e"],"names":["content","__esModule","default","module","i","locals","exports","add","MimeTypeGroup","getMimeType","fileName","internalData","test","endsWith","mimeTypeGroup","image","renderInPDF","audio","other","mimeTypeEnding","split","pop","_objectSpread","mimeType","renderAttachment","_x","_x2","_renderAttachment","apply","arguments","_asyncToGenerator","regeneratorRuntime","mark","_callee","attachmentData","mimeTypeData","width","height","blob","bitmap","wrap","_context","prev","next","Blob","type","createImageBitmap","sent","abrupt","src","stop","getAttachment","_x3","_x4","_getAttachment","_callee2","attachments","data","decompressedData","_context2","filter","file","RegExp","name","length","compressedContent","inflate","inflater","pako","Inflate","raw","offset","compressedData","end","Math","min","chunk","subarray","push","err","Error","concat","msg","result","___CSS_LOADER_EXPORT___","___CSS_LOADER_API_IMPORT___","props","attachmentPromise","Promise","undefined","attachment","fetch","_this","URL","createObjectURL","buffer","component","staticClass","_vm","attrs","staticStyle","_c","staticRenderFns"],"mappings":"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","file":"7aa589f.js","sourcesContent":["// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!../node_modules/css-loader/dist/cjs.js??ref--3-oneOf-1-1!../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../node_modules/postcss-loader/dist/cjs.js??ref--3-oneOf-1-2!../node_modules/@nuxt/components/dist/loader.js??ref--0-0!../node_modules/vue-loader/lib/index.js??vue-loader-options!./Attachment.vue?vue&type=style&index=0&id=d43c6474&prod&lang=css&\");\nif(content.__esModule) content = content.default;\nif(typeof content === 'string') content = [[module.id, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar add = require(\"!../node_modules/vue-style-loader/lib/addStylesClient.js\").default\nvar update = add(\"52cf32c0\", content, true, {\"sourceMap\":false});","import * as JSZip from \"jszip\";\nimport pako from \"pako\";\n\nexport enum MimeTypeGroup {\n  image,\n  video,\n  audio,\n  other,\n}\n\ninterface MimeTypeData {\n  mimeType: string | undefined;\n  mimeTypeGroup: MimeTypeGroup;\n  mimeTypeEnding: string;\n  renderInPDF: boolean;\n}\nexport interface Attachment {\n  mimeTypeData: MimeTypeData;\n  src?: Uint8Array;\n  fileName: string;\n  width?: number;\n  height?: number;\n}\n\nfunction getMimeType(fileName: string): MimeTypeData {\n  function _internal() {\n    if (/\\.jpe?g$/.test(fileName) || fileName.endsWith(\".png\")) {\n      return {\n        mimeTypeGroup: MimeTypeGroup.image,\n        renderInPDF: true,\n      };\n    }\n    if (\n      fileName.endsWith(\".gif\") ||\n      fileName.endsWith(\".webp\") ||\n      fileName.endsWith(\".svg\")\n    ) {\n      return { mimeTypeGroup: MimeTypeGroup.image, renderInPDF: false };\n    }\n\n    if (fileName.endsWith(\".mp4\") || fileName.endsWith(\".webm\")) {\n      return { mimeTypeGroup: MimeTypeGroup.audio, renderInPDF: false };\n    }\n    if (\n      fileName.endsWith(\".mp3\") ||\n      fileName.endsWith(\".m4a\") ||\n      fileName.endsWith(\".opus\") ||\n      fileName.endsWith(\".wav\")\n    ) {\n      return { mimeTypeGroup: MimeTypeGroup.audio, renderInPDF: false };\n    }\n    // unknown file\n    return { mimeTypeGroup: MimeTypeGroup.other, renderInPDF: false };\n  }\n\n  const internalData = _internal();\n  const mimeTypeEnding = fileName.split(\".\").pop() || \"\";\n  return {\n    mimeTypeEnding,\n    ...internalData,\n    mimeType: internalData.mimeTypeGroup + \"/\" + mimeTypeEnding,\n  };\n}\n\nasync function renderAttachment(\n  fileName: string,\n  attachmentData?: Uint8Array\n): Promise<Attachment> {\n  // if the attachmentData is null (because we were not able to find the file)\n  // we set the mimetype to the same format as an unknown file\n  const mimeTypeData: MimeTypeData = attachmentData\n    ? getMimeType(fileName)\n    : {\n        mimeTypeGroup: MimeTypeGroup.other,\n        mimeTypeEnding: fileName.split(\".\").pop() || \"\",\n        mimeType: MimeTypeGroup.other + \"/\" + fileName.split(\".\").pop(),\n        renderInPDF: false,\n      };\n\n  let width, height;\n  if (mimeTypeData.mimeTypeGroup === MimeTypeGroup.image && attachmentData) {\n    // Create a blob from the uint8array data\n    const blob = new Blob([attachmentData], {\n      type: getMimeType(fileName).mimeType,\n    });\n\n    // Create a bitmap image from the blob data\n    const bitmap = await createImageBitmap(blob);\n    (width = bitmap.width), (height = bitmap.height);\n  }\n\n  return {\n    mimeTypeData,\n    src: attachmentData,\n    fileName: fileName,\n    width,\n    height,\n  };\n}\n\n// gets attachment mimeType, src, and filename from attachments\nexport async function getAttachment(\n  fileName: string,\n  attachments: Array<{\n    name: string;\n    compressedContent?: Uint8Array;\n    decompressedData?: Uint8Array;\n  }>\n): Promise<Attachment> {\n  // potentially this finds files that are a false match\n  // but there is the case that the images are in the \"zip\" folder, so we need\n  // to be sure to find em\n\n  const data: any = attachments.filter((file) =>\n    RegExp(\".*\" + fileName).test(file.name)\n  );\n\n  if (data.length === 0) {\n    // sometimes we can not find the attachment\n    return renderAttachment(fileName);\n  }\n  let decompressedData;\n\n  if (data[0].compressedContent) {\n    // this means we have a zip file and have to inflate it frrst\n    decompressedData = inflate(data[0]);\n  } else {\n    // this means a list of files was uploaded\n    decompressedData = data[0].decompressedData;\n  }\n\n  return renderAttachment(fileName, decompressedData);\n}\n\n// this functions inflates ziped files\nfunction inflate(data: any) {\n  const inflater = new pako.Inflate({ raw: true });\n  const chunkSize = 1024; // adjust as needed\n  let offset = 0;\n\n  // needed to unkompress this by hand\n  const compressedData = data.compressedContent;\n  while (offset < compressedData.length) {\n    const end = Math.min(offset + chunkSize, compressedData.length);\n    const chunk = compressedData.subarray(offset, end);\n    inflater.push(chunk);\n    offset = end;\n  }\n\n  if (inflater.err) {\n    throw Error(`Error inflating data: ${inflater.msg}`);\n  } else {\n    const decompressedData = inflater.result;\n    // use uint8 array instead, the width and height can be calculated in the render attachment function\n    return decompressedData;\n  }\n}\n","export * from \"-!../node_modules/vue-style-loader/index.js??ref--3-oneOf-1-0!../node_modules/css-loader/dist/cjs.js??ref--3-oneOf-1-1!../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../node_modules/postcss-loader/dist/cjs.js??ref--3-oneOf-1-2!../node_modules/@nuxt/components/dist/loader.js??ref--0-0!../node_modules/vue-loader/lib/index.js??vue-loader-options!./Attachment.vue?vue&type=style&index=0&id=d43c6474&prod&lang=css&\"","// Imports\nvar ___CSS_LOADER_API_IMPORT___ = require(\"../node_modules/css-loader/dist/runtime/api.js\");\nvar ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(function(i){return i[1]});\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \".media-style img,a,audio,video{max-height:50vh;max-width:100%}.center{bottom:0;left:-10px;position:absolute;right:0;top:0}.rando-file-container{background-color:rgba(0,0,0,.2);border-radius:5px;margin:0;padding:2px 0 2px 10px}\", \"\"]);\n// Exports\n___CSS_LOADER_EXPORT___.locals = {};\nmodule.exports = ___CSS_LOADER_EXPORT___;\n","import mod from \"-!../node_modules/babel-loader/lib/index.js??ref--2-0!../node_modules/@nuxt/components/dist/loader.js??ref--0-0!../node_modules/vue-loader/lib/index.js??vue-loader-options!./Attachment.vue?vue&type=script&lang=js&\"; export default mod; export * from \"-!../node_modules/babel-loader/lib/index.js??ref--2-0!../node_modules/@nuxt/components/dist/loader.js??ref--0-0!../node_modules/vue-loader/lib/index.js??vue-loader-options!./Attachment.vue?vue&type=script&lang=js&\"","\nimport { MimeTypeGroup } from \"~/functions/attachments\";\nexport default {\n  name: \"Attachment\",\n  props: {\n    attachmentPromise: {\n      type: Promise,\n      default: undefined,\n    },\n  },\n  data() {\n    return {\n      attachment: undefined,\n      MimeTypeGroup,\n    };\n  },\n  async fetch() {\n    let attachment = await this.attachmentPromise;\n    // transform uint8array to url\n    attachment.src = URL.createObjectURL(new Blob([attachment.src.buffer]));\n    this.attachment = attachment;\n  },\n};\n","import { render, staticRenderFns } from \"./Attachment.vue?vue&type=template&id=d43c6474&\"\nimport script from \"./Attachment.vue?vue&type=script&lang=js&\"\nexport * from \"./Attachment.vue?vue&type=script&lang=js&\"\nimport style0 from \"./Attachment.vue?vue&type=style&index=0&id=d43c6474&prod&lang=css&\"\n\n\n/* normalize component */\nimport normalizer from \"!../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\nexport default component.exports"],"sourceRoot":""}